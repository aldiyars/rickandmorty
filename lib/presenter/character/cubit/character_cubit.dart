import 'package:bloc/bloc.dart';import 'package:freezed_annotation/freezed_annotation.dart';import 'package:rickandmorty/data/rest_client.dart';import 'package:rickandmorty/domain/entities/character.dart';part 'character_state.dart';class CharacterCubit extends Cubit<CharacterState> {  CharacterCubit(this._client) : super(CharacterInitialState()) {    loadCharacters();  }  final RestClient _client;  int _page = 1;  bool _isLastPage = false;  Future<void> loadCharacters({onRefresh = false}) async {    if (state is CharacterLoadingState || _isLastPage) return;    if (onRefresh) {      _isLastPage = false;      _page = 1;    }    try {      List<Character> oldCharacters = [];      final currentState = state;      if (state is CharacterSuccesLoadedState) {        oldCharacters = (currentState as CharacterSuccesLoadedState).characters;      }      emit(CharacterLoadingState(oldCharacters, isFirstFetch: _page == 1));      await _client.getCharacters(_page).then((value) {        if (value.info?.next == null) {          _isLastPage = true;        } else {          _page++;        }        final newDate = value.results ?? [];        final characters = (state as CharacterLoadingState).oldCharacters;        characters.addAll(newDate);        emit(CharacterSuccesLoadedState(onRefresh ? newDate : characters));      });    } catch (e) {      emit(CharacterErrorState(error: e));    }  }}